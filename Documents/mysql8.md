# MySQL

## Login

```bash
drenv allow
docker-compose exec mysql mysql -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE}
```

## 実行計画 (explain)

### type

| type            | 内容                                                                                                                                           |
|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| ALL             | インデックスを用いない、テーブルスキャン。このタイプが出たら要注意。改善の余地あり。                                                                                                   |
| const           | RIMARY KEY やUNIQUE KEYによる等価比較が行われたときのタイプ。これらのキーには重複したレコードが無いため、キーとリテラル（具体的な値）の条件でクエリ実行されると結果は0行か1行のみになる。この場合、オプティマイザは検索結果を定数( const)のようにみなす。 |
| index           | フルインデックススキャン。良さげな名前だけど、該当のインデックスをスキャンする重い処理。ORDER BY + LIMITで行数を絞り込んでいる場合は、先頭の数エントリを読み込むだけで済むので問題にはならない。                                     |
| eq_ref          | JOINするときにPRIMARY KEYやUNIQUE KEYが使われることを表す。constに似ているが、JOINの内部表へのアクセスで用いられる点が異なる。                                                             |
| ref             | PRIMARY KEY、UNIQUE KEYでないインデックス（ユニークでないインデックス）を使って等価検索(WHERE key = value)を行うことを表す。JOINでも単一テーブルのSELECTでもインデックスがユニークでなければ、refになる。              |
| ref_or_null     | PRIMARY, UNIQUE でないインデックスを使って等価検索(WHERE key = value)を行い、かつOR条件で同じインデックスに対してIS NULLが指定されているときに使われるタイプ。                                        |
| range           | インデックスを用いた範囲検索（不等号やBETWEEN）。検索範囲が大きくても小さくてもrangeとなるので注意が必要。                                                                                  |
| fulltext        | フルテキストインデックスを利用した場合のタイプ。                                                                                                                     |
| index_merge     | 2種類のインデックスを使用し、フェッチした行が統合されるときに利用されるタイプ。                                                                                                     |
| unique_subquery | DEPENDENT SUBGUERY においてPRIMARY KEY、UNIQUE KEYのインデックスを用いてサブクエリが評価されるタイプ。とても高速。                                                                |
| index_subquery  | DEPENDENT SUBGUERY においてユニークではないインデックスを用いてサブクエリが評価されるタイプ。そこそこ高速。                                                                              |


### possible_keys, key, key_len

possible_keysはオプティマイザが利用可能なインデックスの候補として挙げたキー一覧。

keyは、実際にオプティマイザに選択されたキー。どのインデックスが使われるかはkeyを見ればわかる。

key_lenは、選択されたキーの長さ。


### ref 

検索条件で、keyと比較されている値やカラムが表示される。

リテラル（定数）が指定されている場合は、constと表示され、JOINしている場合は、結合する相手側のテーブルで参照されるカラムが表示される。

冒頭のEXPLAIN例では、filmテーブルがfilm_actorテーブルのfilm_idカラムを参照してJOINしていることを意味する。

### rows

テーブルからフェッチされる行数の見積もり。（推定値）

この項目はあくまでも見積もりなので、実際にフェッチされる正確な行数ではない。また、フェッチされた全ての行が結果として返されるわけでもない。

Extraに「Using where」が表示されている場合は、フェッチした行に対してさらにWHERE句で絞り込んだものが結果として返される。

クエリ実行するためにオプティマイザがどんな戦略を選択したかを示す。

Using Where
テーブルから行をフェッチしたあとにWHERE句の条件で絞り込んでいることを意味する。

インデックスを使っていて、適切な行数まで絞り込めているなら、Using whereが表示されていても気にすることはないが、次の場合には注意・改善が必要。


### Extra

クエリ実行するためにオプティマイザがどんな戦略を選択したかを示す。

#### Using Where
テーブルから行をフェッチしたあとにWHERE句の条件で絞り込んでいることを意味する。

インデックスを使っていて、適切な行数まで絞り込めているなら、Using whereが表示されていても気にすることはないが、次の場合には注意・改善が必要。

- レコードアクセスタイプ（type項目）がテーブルスキャン（ALL）または、インデックススキャン（index）
- インデックスを使っているがフェッチする行数（rows）がとても多く、その大半がWHERE句で絞り込まれる（はじかれる）
- JOIN時に内部表でUsing whereが表示されている

#### Using filesort 

MySQLのソートには2通りあって、

1つはインデックスの順番で行をフェッチする方法。この方法は高速。
もう1つは、行をフェッチしてから並び替える方法で、この行のソートアルゴリズムをfilesortと呼ぶ。ファイルソートの中身はクイックソートですが、テンポラリファイルとメモリ上のバッファをりようするためこのような名前になっている。

ファイルソートは常に処理が遅いわけではなく、行数が少なければ十分に高速なので、Using filesortが表示されたときに注意しないといけないのは、ソートされる行数。ソートする行数が多い場合は、インデックスを追加して、クエリがインデックスの順番でソートできるようにすると良い。

このUsing filesortは、JOINを行うときに注意が必要。MySQLがJOIN時にソートを実行するには、次の3つの方法のみ。
※ 上から効率の良い順。

- 駆動表をインデックスの順番で行をフェッチしてソートされた状態でJOINする。この場合は、「Using filesort」は表示されない。
- 駆動表に対してファイルソートして、ソートされた状態でJOINする。この場合は、駆動表において「Using filesort」が表示される。
- JOINを全て実行した後にファイルソートを行う。駆動表において「Using temporary; Using filesort」が表示される。
 
内部表をJOINするときには、インデックス順に行をフェッチするのは不可能なので、JOINを終えたあとにファイルソートするしかない。

これらの方法は、上から効率の良い順になっているので、ソートする行数が多い場合には、3番目より2番目、2番目より1番目のソートになるようにクエリやインデックスをチューニングした方が良い。

##### ポイント
- 1, 2番目の方法になるようにするには、ソートするカラムがあるテーブルを駆動表になるようにする
- 複数のテーブルのカラムでソートする場合は、3番目の方法を取らざるを得ないので、仕様やテーブル設計を見直すか、MySQL以外の方法でなんとかするか

#### Using temporary

クエリ実行にテンポラリテーブルが必要なことを意味する。
MySQLがクエリ実行時に内部的にテンポラリテーブルを利用するのは次の場合。

JOINの結果をソートする場合
ORDER BY と DISTINCTを併用した場合
集計関数を使う場合
UNION
DERIVED
これらの内、DERIVEDやUNIONでは「Using temporary」は表示されない。
なので、「Using temporary」が表示されるのは上記のJOIN時のソートでテンポラリテーブルが必要な場合、集計関数を使う場合、ORDER BYとDISTINCTを併用した場合の3つ。
